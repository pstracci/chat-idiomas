// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum NotificationType {
  CONNECTION_REQUEST
  SYSTEM_MESSAGE
}

model User {
  id        String    @id @default(uuid())
  nickname  String    @db.VarChar(10)
  email     String    @unique
  password  String?
  googleId   String?   @unique
  facebookId String?   @unique
  emailConsent Boolean @default(false)

  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?

  isOnline  Boolean   @default(false)
  lastSeen  DateTime  @default(now())
  credits   Int       @default(10)
  role      Role      @default(USER)
  
  profile   Profile?
  sentConnections     Connection[]     @relation("sentConnections")
  receivedConnections Connection[]     @relation("receivedConnections")
  
  conversations       Conversation[]   @relation("participants")
  sentMessages        Message[]
  notifications       Notification[]
  
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  isVerified                    Boolean    @default(false)
  emailConfirmationToken        String?    @unique
  emailConfirmationTokenExpires DateTime?
  @@index([email])
}

model Profile {
  id                String    @id @default(uuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName         String?
  lastName          String?
  dateOfBirth       DateTime?
  phone             String?
  country           String?
  profilePicture    String?
  languagesSpoken   Json      @default("[]") 
  languagesLearning String[]  @default([])
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  @@index([userId])
}

model Session {
  sid    String   @id
  sess   Json
  expire DateTime
  @@map("session")
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model Connection {
  id          String           @id @default(uuid())
  requesterId String
  addresseeId String
  status      ConnectionStatus @default(PENDING)
  requester   User             @relation("sentConnections", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee   User             @relation("receivedConnections", fields: [addresseeId], references: [id], onDelete: Cascade)
  createdAt   DateTime         @default(now())
  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
}

model Notification {
  id         String           @id @default(uuid())
  userId     String           
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type       NotificationType
  content    String           
  relatedId  String?
  read       Boolean          @default(false)
  createdAt  DateTime         @default(now())

  @@index([userId])
}

model Conversation {
  id           String    @id @default(uuid())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  participants User[]    @relation("participants")
  messages     Message[]

  @@map("conversations")
}

model Message {
  id             String       @id @default(uuid())
  createdAt      DateTime     @default(now())
  
  text           String?      
  imageUrl       String?      

  // --- CAMPO ADICIONADO ---
  read           Boolean      @default(false) // Para rastrear se a mensagem foi lida

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId       String
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("messages")
}